# This script is part of the vieweach CPrAN plugin for Praat.
# The latest version is available through CPrAN or at
# <http://cpran.net/plugins/vieweach>
#
# The vieweach plugin is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# The vieweach plugin is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with vieweach. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2015 Jose Joaquin Atria

include ../../plugin_selection/procedures/selection.proc

preferencesDirectory$ = replace_regex$(preferencesDirectory$, "(con)?(\.(EXE|exe))?$", "", 0)

procedure for_each.before_iteration ()
endproc

procedure for_each.at_begin_iteration ()
endproc

procedure for_each.action ()
endproc

procedure for_each.at_end_iteration ()
endproc

procedure for_each.finally ()
  selectObject: for_each.sets
  runScript: for_each.selection_scripts$ +
    ... "restore_selection.praat"
endproc

procedure for_each ()
  .selection_scripts$ = preferencesDirectory$ + "/plugin_selection/scripts/"

  .total_sets = numberOfSelected("Table") + numberOfSelected("Strings")

  if .total_sets
    runScript: .selection_scripts$ + "save_selection.praat"
    .sets = selected("Table")
    Rename: "foreach_sets"

    .max_items = 0
    for .set to .total_sets
      selectObject: Object_'.sets'[.set, "id"]
      .type$ = Object_'.sets'$[.set, "type"]
      .items = do("Get number of " +
        ... if .type$ = "Table" then "rows" else "strings" fi)
      .max_items = if .items > .max_items then .items else .max_items fi
    endfor
    .last = .max_items
    .total_items = .last       ; For backwards compatibility

    nocheck selectObject: undefined

    if !variableExists("for_each.start_from")
      .start_from = 1
    endif
    .start_from = if .start_from = undefined then 1 else .start_from fi
    .current = .start_from
    .item = .current           ; For backwards compatibility
    .next = 1

    @for_each.before_iteration()
    while .current > 0 and .current <= .total_items
      .item = .current         ; For backwards compatibility
      @for_each.at_begin_iteration()

      @createEmptySelectionTable()
      .selection = createEmptySelectionTable.table
      selectObject: .selection
      Rename: "foreach_selection"

      @createEmptySelectionTable()
      .remove = createEmptySelectionTable.table
      selectObject: .remove
      Rename: "foreach_remove"

      @for_each._select()

      selectObject: .selection
      runScript: .selection_scripts$ + "restore_selection.praat"

      @for_each.action()

      selectObject: .remove
      runScript: .selection_scripts$ + "restore_selection.praat"
      nocheck Remove
      removeObject: .selection, .remove

      @for_each.at_end_iteration()

      if !.next
        .current += .last
      else
        .current += .next
      endif

    endwhile

    @for_each.finally()
    removeObject: .sets

  endif
endproc

procedure for_each._select ()
  for .s to for_each.total_sets
    .set = Object_'for_each.sets'[.s, "id"]
    .type$ = Object_'for_each.sets'$[.s, "type"]
    selectObject: .set
    .items = do("Get number of " +
      ... if .type$ = "Table" then "rows" else "strings" fi)

    .i = ((for_each.current - 1) mod .items) + 1
    if .type$ = "Table"
      .id = Object_'.set'[.i, "id"]
    else
      selectObject: .set
      .filename$ = Get string: .i
      .id = Read from file: .filename$

      @addToSelectionTable: for_each.remove, .id
    endif
    @addToSelectionTable: for_each.selection, .id
  endfor
endproc

procedure for_each.clean_exit (.message$)
  nocheck removeObject: for_each.sets
  nocheck removeObject: for_each.selection
  nocheck removeObject: for_each.remove
  exitScript: .message$ + newline$
endproc
