# View each selected Sound (and TextGrid) object in turn
#
# The script allows for easy navigation between selected Sound
# objects, which is particularly useful when comparing specific
# features in each of them. If an equal number of TextGrid and
# Sound objects have been selected, they will be paired by name
# and viewed in unison.
#
# Written by Jose J. Atria (October 14, 2012)
# Last revision: July 10, 2014)
#
# This script is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# A copy of the GNU General Public License is available at
# <http://www.gnu.org/licenses/>.

procedure view_each.before_iteration ()
endproc

procedure view_each.at_begin_iteration ()
endproc

procedure view_each.at_begin_editor ()
  .editor$ = Editor info
  view_each.name$ = extractLine$(.editor$, "Editor name: ")
  view_each.name$ = mid$(view_each.name$,
    ... rindex(view_each.name$, " "), length(view_each.name$))
endproc

procedure view_each.at_end_editor ()
  Close
endproc

procedure view_each.after_end_editor ()
endproc

procedure view_each.at_end_iteration ()
endproc

procedure view_each.finally ()
endproc

procedure view_each.pause ()
  beginPause: "Viewing " + view_each.name$ + " " +  "(" +
      ... string$(for_each.item) + " of " +
      ... string$(for_each.total_items) + ")"

  if for_each.item > 1
    .button = endPause: "Stop", "Previous",
      ... if for_each.item = for_each.total_items then
      ... "Finish" else "Next" fi, 3, 1
  else
    .button = endPause: "Stop",
      ... if for_each.item = for_each.total_items then
      ... "Finish" else "Next" fi, 2, 1
  endif

  if .button = 1
    # Pressed stop
    for_each.next = 0
  elsif .button = 2 and for_each.item > 1
    # Pressed back
    for_each.next = -1
  else
    # Pressed forward
    for_each.next = if for_each.item = for_each.total_items then 0 else 1 fi
  endif
endproc

procedure for_each.before_iteration ()
  @view_each.before_iteration()
endproc

procedure for_each.at_begin_iteration ()
  @view_each.at_begin_iteration()
endproc

procedure for_each.at_end_iteration ()
  @view_each.at_end_iteration()
endproc

procedure for_each.finally ()
  @view_each.finally()
endproc

procedure for_each.action ()
  if numberOfSelected()
    @has_editor()
    if has_editor.editor
      do(has_editor.command$)
      editor: has_editor.editor
        @view_each.at_begin_editor()
      endeditor

      @view_each.pause()

      nocheck editor: has_editor.editor
        # Hook within editor, after the pause
        @in_editor()
        if in_editor.return
          @view_each.at_end_editor()
        endif
      nocheck endeditor

      # Hook called after at_end_editor,
      # which might not be in an editor
      @view_each.after_end_editor()
    endif
  endif
endproc

include ../procedures/for_each.proc
procedure view_each ()
  @for_each()
endproc

procedure in_editor ()
  .info$ = nocheck Editor info
  .return = if .info$ = "" then
    ... 0 else extractNumber(.info$, "Editor name: ") fi
endproc

procedure has_editor ()
  .command$ = "View & Edit"
  .editor = 0
  @_try_editor: .command$
  if !'_try_editor.return'
    .command$ = "Edit"
    @_try_editor: .command$
  endif
  if !'_try_editor.return'
    .command$ = "View"
    @_try_editor: .command$
  endif
  .editor = '_try_editor.return'
endproc

procedure _try_editor: .command$
  nocheck do(.command$)
  for .i to numberOfSelected()
    nocheck editor: selected(.i)
      @in_editor()
      nocheck Close
    nocheck endeditor
  endfor
  .return = in_editor.return
endproc
